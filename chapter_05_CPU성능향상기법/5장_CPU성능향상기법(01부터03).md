https://gray-oboe-0b5.notion.site/5-CPU-e700de82f06b4cde91407ec46ee31749

## 목표

- 빠른 CPU를 위한 설계 기법을 학습한다.
- 빠른 CPU를 위한 명령어 병렬 처리 기법을 학습한다.
- RISC와 CISC의 차이에 대해 학습한다.

## 05-1. 빠른 CPU를 위한 설계 기법

### 1. 클럭

- 클럭의 역할
    - 컴퓨터 부품들은 클럭 신호에 맞춰 움직인다.
    - CPU는 명령어 사이클이라는 정해진 흐름에 맞춰 명령어들을 실행한다.
- 클럭 신호가 빠르게 반복되면 CPU를 비롯한 컴퓨터 부품들은 그만큼 빠른 박자에 맞춰 움직인다. 즉, 클럭 속도가 높아지면 CPU는 명령어 사이클을 더 빠르게 반복하게 된다. 이때문에 클럭 속도는 CPU 속도 단위로 간주되기도 한다.
- 클럭 속도
    - 헤르츠(Hz) 단위로 측정한다. 1초에 클럭이 몇번 반복되는지 나타낸다.
    - 1초에 한 번 반복되는 CPU 클럭 속도는 1Hz, 클럭이 1초에 100번 반복되면 CPU 클럭 속도는 100Hz이다.
- 클럭 속도를 무작정 높이게 되면 발열 문제가 심각해져 클럭 속도만으로 CPU의 성능을 올리는 것은 한계가 있다.

<aside>
💡 **클럭 속도는 일정하지 않다.**
- CPU는 클럭속도와 최대클럭속도로 나뉘어 있다. 이처럼 CPU는 계속 일정한 클럭속도를 유지하기보다는 고성능을 요하는 순간에는 순간적으로 클럭 속도를 높이고, 그렇지 않을 때는 유연하게 클럭 속도를 낮추기도 한다.
- 오버클럭킹(overclocking): 최개 클럭 속도를 강제로 더 끌어 올릴 수 있는데 이런 기법을 오버클럭킹 이라 한다.

</aside>

### 2. 코어와 멀티코어

- 코어의 의미
    - 명령어를 실행하는 부품
    - 오늘날의 CPU는 단순히 “명령어를 실행하는 부품”에서 “명령어를 실행하는 부품을 여러 개 포함하는 부품”으로 명칭의 범위가 확장 되었다. ⇒ CPU가 8코어라는 것은 명령어를 실행하는 부품을 여덞개 포함하고 있다고 보면 된다.
- 코어를 여러 개 포함하고 있는 CPU를 **멀티코어CPU** 또는 **멀티코어 프로세서**라고 부른다.
- CPU의 연산 속도가 꼭 코어 수에 비례하여 증가하지는 않는다.
    - 처리하고자 하는 작업량보다 코어 수가 지나치게 많아도 성능에는 크게 영향이 없다.
    - 코어마다 처리할 명령어들을 얼마나 적절하게 분배하느냐이고 그에 따라 연산속도는 크게 달라진다.

### 3. 스레드와 멀티스레드

- 스레드
    - 사전적 의미로는 실행 흐름의 단위
        
        1) 하드웨어적 스레드
        
        - 스레드를 하드웨어적으로 정의하면 ‘하나의 코어가 동시에 처리하는 명령어 단위’를 의미한다.
        - 하나의 코어로 여러 명령어를 동시에 처리하는 CPU를 **멀티스레드 프로세서** 또는 **멀티스레드 CPU**라고 한다.
        
        2) 소프트웨어적 스레드
        
        - 소프트웨어적으로 정의된 스레드는 ‘하나의 프로그램에서 독립적으로 실행되는 단위’를 의미한다.
            - 예를들면 워드 프로세서 프로그램에서 (1) 사용자로부터 입력받은 내용을 화면세 보여주는 기능 (2) 사용자가 입력한 내용이 맞춤법에 맞는지 검사하는 기능 (3) 사용자가 입력한 내용을 수시로 저장하는 기능들을 동시에 수행하는 것이다.
        - 한 번에 하나씩 명령어를 처리하는 1코어 1스레드 CPU도 소프트웨어적 스레드를 수십 개 실행할 수 있다. 즉, 1코어 1스레드 CPU로도 프로그램의 여러 부분을 동시에 실행 할 수 있다.
- 멀티스레드 프로세서
    - 하나의 코어로 여러 명령어를 동시에 처리하는 CPU
    - 논리 프로세서 (logical proccesor)
        - 메모리 속 프로그램 입장에서 봤을 때 하드웨어 스레드는 마치 ‘한번에 하나의 명령어를 처리하는 CPU’나 다름 없다. 예를 들면 2코어 4스레드 CPU는 한번에 네개의 명령어를 처리할 수 있는데, 프로그램 입장에서 봤을 땐 한 번에 하나의 명령어를 처리하는 CPU가 네 개 있는 것처럼 보인다.
            
            그래서 하드웨어 스레드를 논리 프로세서라고 부르기도 한다.
            

### 4. 요약

- 코어
    - 명령어를 실행 할 수 있는 하드웨어 부품
- 스레드
    - 명령어를 실행하는 단위
- 멀티코어 프로세서
    - 명령어를 실행할 수 있는 하드웨어 부품이 CPU 안에 두 개 이상 있는 CPU
- 멀티스레드 프로세서
    - 하나의 코어로 여러개의 명령어를 동시에 실행할 수 있는 CPU

## 05-2. 명령어 병렬 처리 기법

빠른 CPU를 만들려면 높은 클럭 속도, 멀티코어, 멀티스레드를 지원하는 CPU를 만드는 것도 중요하지만 CPU가 놓지 않고 시간을 알뜰하게 쓰며 작동하게 만드는 것도 중요하다.

**명령어 병렬 처리 기법**

- 명령어를 동시에 처리하여 CPU를 한시도 쉬지 않고 작동시키는 기법

### 1. 명령어 파이프라인

명령어 처리 과정을 클럭 단위로 나누어 보면 다음이 나눌 수 있다.

1) 명령어 인출 (Instruction Fetch)

2) 명령어 해석 (Instruction Decode)

3) 명령어 실행 (Execute Instruction)

4) 결과 저장 (Write Back)

같은 단계가 겹치지 않으면 CPU는 각 단계를 동시에 실행 할 수 있다.

⇒ 명령어 파이프라인에 넣고 동시에 처리하는 기법을 **명령어 파이프라이닝**이라고 한다.

- 파이프라인 위험
    - 데이터 위험
        - 명령어 간 데이터 의존성에 의해 발생
        - 데이터 의존적인 두 명령어를 무작정 동시에 실행하려고 하면 파이프라인이 제대로 작동하지 않는 것을 ‘데이터 위험’이라고 한다.
    - 제어위험
        - 분기 등으로 인한 프로그램 카운터의 갑작스러운 변화에 의해 발생
        - 기본적으로 프로그램 카운터는 ‘현재 실행 중인 명령어의 다음 주소’로 갱신된다. 하지만 프로그램 실행 흐름이 바뀌어 명령어가 실행되면서 프로그램 카운터 값에 갑작스러운 변화가 생긴다면 명령어 파이프라인에 미리 가지고 와서 처리 중이었던 명령어들은 아무 쓸모가 없어진다.
            
            ⇒ 이를 제어위험이라 한다.
            
        - 분기예측
            - 제어위험을 위해 사용하는 기술
            - 프로그램이 어디로 분기할지 미리 예측한 후 그 주소를 인출하는 기술
    - 구조적 위험
        - 명령어들을 겹쳐 실행하는 과정에서 서로 다른 명령어가 동시에 ALU, 레지스터 등과 같은 CPU 부품을 사용하려고 할 때 발생
        - 자원위험 이라고도 한다.

### 2. 슈퍼스칼라

- CPU 내부에 여러 개의 명령어 파이프라인을 포함한 구조
- 슈퍼스칼라 구조로 명령어 처리가 가능한 CPU를 슈퍼스칼라 프로세서 또는 슈퍼스칼라 CPU라고 한다.

### 3. 비순차적 명령어 처리

- 명령어 병렬 처리 기법은 비순차적 명령어 처리이다.
- 오늘날 CPU 성능 향상에 크게 기여한 기법이자 대부분의 CPU가 차용하는 기법이다.
- 명령어를 순차적으로만 실행하지 않고 순서를 바꿔 실행해도 무방한 명령어를 먼저 실행하여 명령어 파이프라인이 멈추는 것을 방지하는 기법
    - 비순차적 명령어 처리가 가능한 CPU는 명령어들이 어떤 명령어와 데이터 의존성을 가지고 있는지, 순서를 바꿔 실행할 수 있는 명령어에는 어떤 것들이 있는지 판단할 수 있어야 한다.
    

## 05-3. CISC와 RISC

CPU가 파이프라이닝과 슈퍼스칼라 기법을 효과적으로 사용하려면 CPU가 인출하고 해석하고 실행하는 명령어가 파이프라이닝 하기 쉽게 생겨야 한다.

CPU의 언어인 ISA와 각기 다른 성격의 ISA를 기반으로 설계된 CISC와 RISC를 학습한다.

### 1. 명령어 집합 (ISA)

- CPU가 이해할 수 있는 명령어들의 모음으로 CPU마다 ISA가 다를 수 있다.
- CPU가 이해하는 명령어들이 달라지면 명령어의 생김새만 달라지는 것이 아니다.
    - ISA가 달라지면 제어장치가 명령어를 해석하는 방식, 사용되는 레지스터의 종류과 개수, 메모리 관리 방법 등 많은 것이 달라진다. ⇒ CPU 하드웨어 설계에도 큰 영향을 미친다.
    - ISA는 CPU의 언어임과 동시에 CPU를 비롯한 하드웨어가 소프트웨어를 어떻게 이해할지에 대한 약속이라고 볼 수 있다.
    

### 2. CISC

- 다양하고 강력한 기능의 명령어 집합을 활용하기 때문에 명령어의 형태와 크기가 다양한 **가변 길이 명령어**를 활용한다.
- 장점: 적은 수의 명령어만으로도 프로그램을 동작 시킬 수 있기 때문에 메모리 공간을 절약 할 수 있다는 장점이 있다. ⇒ 메모리를 최대한 아끼며 개발해야 했던 시절에 인기가 높았다.
- 단점: 활용하는 명령어가 복잡하고 다양한 기능을 제공하는 타셍 명령어의 크기와 실행되기까지의 시간이 일정하지 않다. 복잡한 명령어 때문에 명령어 하나를 실행하는 데에 여러 클럭 주기를 필요로 한다.
    - CISC가 활용하는 명령어는 명령어 수행 시간이 길고 가지각색이기 때문에 파이프라인이 효율적으로 명령어를 처리 할 수 없다. ⇒ 규격화되지 않은 명령어가 파이프라이닝을 어렵게 만든 것이다.

### 3. RISC

- CISC에 비해 명령어의 종류가 적다. 또한 CISC와 달리 짧고 규격화된 명령어, 되도록 1클럭 내외로 실행되는 명령어를 지향한다.
- RISC는 고정 길이 명령어를 활용한다.
- 명령어가 규격화 되어 있고, 하나의 명령어가 1클럭 내외로 실행되기 때문에 RISC 명령어 집합은 명령어 파이프라이닝에 최적화 되어 있다.
- RISC는 메모리에 직접 접근하는 명령어를 load, store 두 개로 제한할 만큼 메모리 접근을 단순화하고 최소화를 추구한다.
    - RISC는 메모리 접근을 단순화, 최소화 하는 대신 레지스터를 적극적으로 활용한다. ⇒ CISC보다 레지스터를 이용하는 연산이 많고, 일반적인 경우보다 범용 레지스터 개수도 더 많다.